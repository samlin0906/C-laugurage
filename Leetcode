//009 palindrome integer 回文數

bool isPalindrome(int x){
    if (x < 0) 
        return false;
    long int temp = x, total = 0;   // 需設long int
    while (temp != 0) {
        total = total * 10 + temp % 10;
        temp = temp / 10;
    }
    if (total == x)              // 需等於x 非 temp
        return true;
    return false;
}

//014  Longest Common Prefix
//雙指標 二維
//深度優先遍歷 縱向遍歷圖

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char * longestCommonPrefix(char ** strs, int strsSize){
    int i, j, index, tempindex;                            
    if (strsSize <= 1)
        return *strs;                                   //不可寫""
    index = strlen(strs[0]);                            //strlen不包含'\0'
    char *a;
    a = (char *)malloc(sizeof(char) * (index + 1));    //(char*)是用來轉換void類型的malloc; (index + 1)是將'\0'加入,以便後續停止運作
    strcpy(a, strs[0]);                                //將strs[0]當作對照組
    for (i = 1; i < strsSize; i++) {
        tempindex = 0;
        for (j = 0; j < index; j ++) {
            if (a[j] == strs[i][j])
                tempindex++;
            else {                                    //不可寫else if, else 代表 false
                a[j] = '\0';
                break;
            }

        }
        if (tempindex == 0)
            return "";
        if (tempindex <= index)
            index = tempindex;                        //不可寫tempindx = index

    }
    free(a);
    return a;
}

int main () {
    char *strs[] = {"f"};
    printf("%s", longestCommonPrefix(strs, 1));
}

//020 Valid Parentheses
//stack, 後進先出
//需在每個迴圈加上 if (top == 0) return false, 要不然leetcode會判定runtime error; https://ithelp.ithome.com.tw/questions/10199167

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

bool isValid(char * s){
    int i, length, top = 0;
    char *stack, c;
    length = strlen(s);
    stack = (char *) malloc(length);                           //malloc(size_t, size); 另一種寫法,無須加入sizeof
    for (i = 0; i < length; ++ i) {
        if (s[i] == ')') {
            c = stack[--top];                                 //不可寫top--, 因為為stack算法,從最後一位開始算
            if (c != '(')
                return false;
        }else if (s[i] == '}') {
            c = stack[--top];
            if (c != '{')
                return false;
        }else if (s[i] == ']') {
            c = stack[--top];
            if (c != '[')
                return false;
        } else {
            stack[top++] = s[i];
        }
    }
    free(stack);
    return top == 0;                                        //意味stack = []; 輸入值如果為空的話,判定True
}


int main () {
    char str[] = {"()}"};
    if (isValid(str))
        printf("True");
    else
        printf("False.");
    return 0;
}

//021 Merge Two Sorted Lists
//struct, Linked list 鏈結串列

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){

    struct ListNode head;
    struct ListNode *h = &head;

    if (l1 == NULL && l2 == NULL)
        return NULL;

    while (l1 && l2) {
        if (l1->val < l2->val) {                         //尋找較小的節點                  
            h->next = l1;
            l1 = l1->next;
        }
        else {
            h->next = l2;
            l2 = l2->next;
        }
        h = h->next;
    }
    if (l1 != NULL)
        h->next = l1;                                  //合併剩餘的list
    if (l2 != NULL)
        h->next = l2;
    return head.next;

}
