//009 palindrome integer 回文數

bool isPalindrome(int x){
    if (x < 0) 
        return false;
    long int temp = x, total = 0;   // 需設long int
    while (temp != 0) {
        total = total * 10 + temp % 10;
        temp = temp / 10;
    }
    if (total == x)              // 需等於x 非 temp
        return true;
    return false;
}

//014  Longest Common Prefix
//雙指標 二維
//二元數 深度優先遍歷 縱向遍歷圖

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char * longestCommonPrefix(char ** strs, int strsSize){
    int i, j, index, count;                            
    if (strsSize <= 1)
        return *strs;                                   //不可寫""
    index = strlen(strs[0]);                            //strlen不包含'\0'
    char *a;
    a = (char *)malloc(sizeof(char) * (index + 1));    //(char*)是用來轉換void類型的malloc; (index + 1)是將'\0'加入,以便後續停止運作
    strcpy(a, strs[0]);                                //將strs[0]當作對照組
    for (i = 1; i < strsSize; i++) {
        count = 0;
        for (j = 0; j < index; j ++) {
            if (a[j] == strs[i][j])
                count++;
            else {                                    //不可寫else if, else 代表 false
                a[j] = '\0';
                break;
            }

        }
        if (count == 0)
            return "";
        if (count <= index)
            index = count;                        //不可寫count = index

    }
    free(a);
    return a;
}

int main () {
    char *strs[] = {"f"};
    printf("%s", longestCommonPrefix(strs, 1));
    return 0;
}

//020 Valid Parentheses
//stack, 後進先出
//需在每個迴圈加上 if (top == 0) return false, 要不然leetcode會判定runtime error; https://ithelp.ithome.com.tw/questions/10199167

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

bool isValid(char * s){
    int i, length, top = 0;
    char *stack, c;
    length = strlen(s);
    stack = (char *) malloc(length);                           //malloc(size_t, size); 另一種寫法,無須加入sizeof
    for (i = 0; i < length; ++ i) {
        if (s[i] == ')') {
            c = stack[--top];                                 //不可寫top--, 因為為stack算法,從最後一位開始算
            if (c != '(')
                return false;
        }else if (s[i] == '}') {
            c = stack[--top];
            if (c != '{')
                return false;
        }else if (s[i] == ']') {
            c = stack[--top];
            if (c != '[')
                return false;
        } else {
            stack[top++] = s[i];
        }
    }
    free(stack);
    return top == 0;                                        //意味stack = []; 輸入值如果為空的話,判定True
}


int main () {
    char str[] = {"()}"};
    if (isValid(str))
        printf("True");
    else
        printf("False.");
    return 0;
}

//021 Merge Two Sorted Lists
//struct, Linked list 鏈結串列

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){

    struct ListNode head;
    struct ListNode *h = &head;

    if (l1 == NULL && l2 == NULL)
        return NULL;

    while (l1 && l2) {
        if (l1->val < l2->val) {                         //尋找較小的節點                  
            h->next = l1;
            l1 = l1->next;
        }
        else {
            h->next = l2;
            l2 = l2->next;
        }
        h = h->next;
    }
    if (l1 != NULL)
        h->next = l1;                                  //合併剩餘的list
    if (l2 != NULL)
        h->next = l2;
    return head.next;

}

//026 Remove Duplicates from Sorted Array
//in-place algorithm 原地演算法
//為避免增加記憶體(新增array), 直接重設計數


#include <stdio.h>

int removeDuplicates(int* nums, int numsSize){

    int i, count = 1;
    if (numsSize == 0)
        return 0;
    for (i = 1; i < numsSize; i++) {
        if (nums[i] != nums[i - 1])
            nums[count++] = nums[i];
    }
    return count;
}

int main () {
    int a[] = {0,0,1,1,1,2,2,3,3,4};
    int size;
    size = sizeof(a) / sizeof(a[0]);
    printf("%d", removeDuplicates(a, size));
    return 0;
}

//035 Search Insert Position
//sorted array
//In order to find 順序查找, O(n)

int searchInsert(int* nums, int numsSize, int target){
    int i;
    for (i =0; i < numsSize; i++) {
        if (nums[i] >= target)
            return i;
    }
    return numsSize;
}

//binary search 二分搜尋, O(logn)

int searchInsert(int* nums, int numsSize, int target){

    int low = 0;
    int high = numsSize - 1;
    int mid = (low + high) / 2;

    while (low <= high) {
        if (nums[mid] == target)
            return mid;
        else if (nums[mid] < target) {
            low = mid + 1;
            mid = (low + high)/2;
        }
        else {
            high = mid - 1;
            mid = (low + high)/2;
        }
    }
    return low;
}

int main () {
    int a[] = {1,3,5,6};
    int size;
    size = sizeof(a) / sizeof(a[0]);
    printf("%d", searchInsert(a, size, 0));
    return 0;
}
